%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{Analyzing "The Distance" by Cake: Signal Processing Approach for Enhanced Audio Experience}
\date{Jul 17, 2023}
\release{}
\author{Shaun Pies}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{intro::doc}}




\sphinxAtStartPar
Signal processing has become an indispensable tool in the world of audio analysis and manipulation. By extracting and manipulating various features of audio signals, it is possible to enhance sound quality, identify specific components, and even create new audio experiences. In this paper, we explore the application of signal processing techniques on the song “The Distance” by Cake, with a focus on the first 30 seconds of the track.

\sphinxAtStartPar
“The Distance” is a highly recognizable and popular alternative rock song that exemplifies Cake’s unique musical style. By subjecting this composition to signal processing techniques, we aim to uncover hidden details, enhance audio clarity, and provide a fresh perspective on the song’s acoustic properties.

\sphinxAtStartPar
Our approach involves a series of steps, starting with the application of the Fast Fourier Transform (FFT) to transform the time\sphinxhyphen{}domain representation of the audio signal into the frequency domain. This transformation enables us to analyze the distribution of frequencies and identify any underlying patterns that may influence the overall sound. By focusing on the first 30 seconds of the song, we can extract and analyze a specific segment that captures the essence of the composition.

\sphinxAtStartPar
To further refine the audio quality and mitigate potential artifacts introduced during the frequency domain analysis, we apply a raised cosine filter. This filter serves to suppress undesired components and emphasize the important frequencies, leading to a cleaner and more focused sound output. The raised cosine filter is selected for its ability to effectively balance between attenuating unwanted frequencies and preserving the desired ones.

\sphinxAtStartPar
After applying the raised cosine filter, we perform the inverse Fourier Transform to convert the filtered frequency\sphinxhyphen{}domain signal back to the time domain. This step reconstructs the processed audio, preserving the key characteristics while incorporating the improvements obtained through the frequency domain manipulation.

\sphinxAtStartPar
Finally, we evaluate the effectiveness of our signal processing approach by playing the processed audio and comparing it to the original version of “The Distance.” By conducting a comprehensive subjective and objective analysis, we aim to demonstrate the enhanced audio experience resulting from our signal processing techniques.

\sphinxAtStartPar
Overall, this paper showcases a novel application of signal processing on the song “The Distance” by Cake. By employing the Fourier Transform, raised cosine filtering, and inverse Fourier Transform, we aim to unlock hidden details and improve the audio quality of the first 30 seconds of the composition. Through our analysis, we seek to provide a fresh perspective on the song’s acoustic properties and offer a valuable contribution to the field of audio signal processing.

\sphinxAtStartPar
In addition to its cultural significance, “The Distance” by Cake holds relevance to scientific research within the field of audio analysis. The selection of this particular song for our signal processing study is not arbitrary; it represents an opportunity to explore the potential of applying advanced techniques to a well\sphinxhyphen{}known and widely appreciated musical composition.

\sphinxAtStartPar
Scientific research often benefits from real\sphinxhyphen{}world examples that resonate with a broad audience. By utilizing a popular song like “The Distance,” we can engage both scientific and non\sphinxhyphen{}scientific communities in the exploration of signal processing methodologies. This approach allows us to bridge the gap between scientific analysis and the general public’s familiarity with the chosen musical piece, fostering greater interest and understanding.

\sphinxAtStartPar
Furthermore, “The Distance” exhibits various sonic elements that make it an intriguing candidate for signal processing analysis. Its composition encompasses a blend of vocals, instrumental tracks, and complex arrangements that challenge conventional audio processing techniques. By focusing on this song, we can address the unique characteristics and challenges present in its audio representation, ultimately contributing to the development of more robust and adaptable signal processing methodologies.

\sphinxAtStartPar
Moreover, the application of signal processing techniques to popular music opens avenues for interdisciplinary collaborations. Researchers from fields such as musicology, psychology, and computer science can converge to explore how signal processing can influence the subjective experience of music. This multidisciplinary approach not only expands the possibilities within audio analysis but also encourages cross\sphinxhyphen{}pollination of ideas and methodologies, leading to novel discoveries and advancements in scientific research.

\sphinxAtStartPar
By acknowledging the importance of “The Distance” in scientific research, we recognize the potential impact of our signal processing study. Through this exploration, we aim to inspire further investigations into the application of advanced audio analysis techniques on well\sphinxhyphen{}known musical compositions. Ultimately, our findings may contribute to the development of innovative approaches in signal processing and shape the future of audio analysis in diverse scientific disciplines.

\begin{sphinxadmonition}{note}{Disclaimer}

\sphinxAtStartPar
This indroduction was written by ChatGPT for a bit of fun. The real introduction is on the next page.
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Signal Processing of the song “The Distance” by Cake}
\label{\detokenize{content/0_project_part2:signal-processing-of-the-song-the-distance-by-cake}}\label{\detokenize{content/0_project_part2::doc}}

\section{Introduction}
\label{\detokenize{content/0_project_part2:introduction}}
\sphinxAtStartPar
In this project we are going to take the song “The Distance” by the band “Cake” and modify the song with the use of a couple different signal processing techniques. We need to import the song data into python so that it is workable. We then will shorten the song to just the first 30 seconds, take the Fourier Transform of those 30 seconds, apply a filter, take the inverse transform, then plot and play the filtered song.

\sphinxAtStartPar
The first steps in analyzing “The Distance” with Python are to import the necessary packages. Those packages are \sphinxcode{\sphinxupquote{numpy}}, \sphinxcode{\sphinxupquote{matplotlib}}, \sphinxcode{\sphinxupquote{scipy}}, and for playing the audio back to us inside the Jupyter Notebook \sphinxcode{\sphinxupquote{IPython}}. We will also use the \sphinxcode{\sphinxupquote{copy}} package from the standard library.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Import necessary modules}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{Audio}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{io} \PYG{k+kn}{import} \PYG{n}{wavfile}
\PYG{k+kn}{from} \PYG{n+nn}{copy} \PYG{k+kn}{import} \PYG{n}{deepcopy}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}

\section{Gather Data}
\label{\detokenize{content/0_project_part2:gather-data}}
\sphinxAtStartPar
First we need to gather the data with the \sphinxcode{\sphinxupquote{scipy}} module. We will use \sphinxcode{\sphinxupquote{scipy.io.wavfile}} to read the wave file and sort it into 3 sections. The sampling rate, left channel, and right channel. Then we used the \sphinxcode{\sphinxupquote{IPython.display.Audio}} class to play the first thirty seconds of the song.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Gather data and play a 30 second segment}
\PYG{n}{song} \PYG{o}{=} \PYG{n}{wavfile}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TheDistance.wav}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{hz} \PYG{o}{=} \PYG{n}{song}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{hz}
\PYG{n}{time} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{)}
\PYG{n}{N} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{n}{time}\PYG{p}{)}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{song}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{T}
\PYG{n}{left\PYGZus{}channel} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{n}{N}\PYG{p}{]}
\PYG{n}{right\PYGZus{}channel} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{n}{N}\PYG{p}{]}
\PYG{n}{channels} \PYG{o}{=} \PYG{p}{[}\PYG{n}{left\PYGZus{}channel}\PYG{p}{,} \PYG{n}{right\PYGZus{}channel}\PYG{p}{]}
\PYG{n}{Audio}\PYG{p}{(}\PYG{n}{channels}\PYG{p}{,} \PYG{n}{rate}\PYG{o}{=}\PYG{n}{hz}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.Audio object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Plot the Data}
\label{\detokenize{content/0_project_part2:plot-the-data}}
\sphinxAtStartPar
To plot the data we used \sphinxcode{\sphinxupquote{matplotlib.pyplot}}. The first 30 seconds of each channel are plotted below

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Plot the data}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{ax}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{v}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{time}\PYG{p}{,} \PYG{n}{channels}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{v}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Time (s)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{v}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Amplitude}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Left Channel}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Right Channel}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{suptitle}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The Distance \PYGZhy{} Cake (first 30 seconds)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{e69f475078837cc4b05c611912fc2f6c71aafa2493a385909b2a51cd112c6115}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Fourier Transform}
\label{\detokenize{content/0_project_part2:fourier-transform}}
\sphinxAtStartPar
The discrete Fourier Transform is defined as
\begin{equation*}
\begin{split}F(k) = \sum_{0}^{N-1}f(n)e^{-i2\pi\frac{kn}{N}}\end{split}
\end{equation*}
\sphinxAtStartPar
An example of the discrete Fourier Transform is shown below. This is a discrete four point Fourier Transform
\begin{equation*}
\begin{split}[yay, yay, yay, yay] \supset [4yay, 0, 0, 0]\end{split}
\end{equation*}
\sphinxAtStartPar
In Python there are several ways to take the Fourier Transform of a set of data. Here we have used the \sphinxcode{\sphinxupquote{numpy}} package and its various \sphinxcode{\sphinxupquote{fft}} algorithms. We have plotted the absolute value of the Fourier Transform of each channel below.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Take the Fourier Transform of each channel and plot it}
\PYG{n}{freqs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{hz} \PYG{o}{/} \PYG{l+m+mi}{2000}\PYG{p}{,} \PYG{n}{hz} \PYG{o}{/} \PYG{l+m+mi}{2000}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}
\PYG{n}{ffts} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{channels}\PYG{p}{:}
    \PYG{n}{ffts}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fft}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{ax}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{v}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{freqs}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{ffts}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{v}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Frequency (kHz)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{v}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Amplitude}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Left Channel}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Right Channel}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{suptitle}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fourier Transform of }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{The Distance}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{f799e1814e8c405820abf5aa7824dafc23432c8e7ad7dfebdfd9a524285ed292}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Design the Filter}
\label{\detokenize{content/0_project_part2:design-the-filter}}
\sphinxAtStartPar
There are several different filters that we could choose to use. A standard rectangle, a Gaussian filter, a Wiener filter and many more. The filter that I chose was a raised cosine filter or also known as a cosine squared filter. This filter has some nice properties. For one it starts at zero and ends at zero which means that there are no sharp edges that can cause some undesired artifacts in the data. It gradually increases in value and at the central value has a maximum amplitude of one then gradually goes back down to zero before the end of the data.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Design the filter}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}
\PYG{n}{cos\PYGZus{}filt} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}

\PYG{c+c1}{\PYGZsh{} Plot the filter}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{freqs}\PYG{p}{,} \PYG{n}{cos\PYGZus{}filt}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Frequency (kHz)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Amplitude}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Raised Cosine Filter}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{ec9d6aee117b6ea720b424150d05708fa590194ed48ae66b849f94a7283428a9}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Apply the Filter}
\label{\detokenize{content/0_project_part2:apply-the-filter}}
\sphinxAtStartPar
To apply the filter to the transformed data we must do term by term multiplication. Python’s default array multiplication is term by term so all that there is to do is multiply the two arrays together (making sure that they are the same length of course).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Apply filter to data}
\PYG{n}{filtered\PYGZus{}ffts} \PYG{o}{=} \PYG{n}{deepcopy}\PYG{p}{(}\PYG{n}{ffts}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{filtered\PYGZus{}ffts}\PYG{p}{:}
    \PYG{n}{i} \PYG{o}{*}\PYG{o}{=} \PYG{n}{cos\PYGZus{}filt}

\PYG{c+c1}{\PYGZsh{} Plot filtered ffts}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{ax}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{v}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{freqs}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{filtered\PYGZus{}ffts}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{v}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Frequency (kHz)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{v}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Amplitude}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Left Channel}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Right Channel}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{suptitle}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Filtered Fourier Transform}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{201f080912dfc31f51ec43958370b8455f6f2d781d5adcb3cc4285580e5c6133}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Once the filter has been applied to the data we then take the inverse Fourier Transform of the filtered data then we can plot and play the filtered data

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Inverse Fourier Transform. Plot. Play.}
\PYG{n}{filtered\PYGZus{}song} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{filtered\PYGZus{}ffts}\PYG{p}{:}
    \PYG{n}{filtered\PYGZus{}song}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{ifft}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{real}\PYG{p}{)}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{ax}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{v}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{time}\PYG{p}{,} \PYG{n}{filtered\PYGZus{}song}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{v}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Time (s)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{v}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Amplitude}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Left Channel}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Right Channel}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{suptitle}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Filtered Song}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{Audio}\PYG{p}{(}\PYG{n}{filtered\PYGZus{}song}\PYG{p}{,} \PYG{n}{rate}\PYG{o}{=}\PYG{n}{hz}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{9a0102d33bc7726098342363d608203d6073349228bbb2404039a8c2a702577a}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.Audio object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Modified Filter}
\label{\detokenize{content/0_project_part2:modified-filter}}
\sphinxAtStartPar
The raised cosine filter did not seem to affect the data very much since most of the frequency information is within about 10 kHz. So in order to see (and hear) what the filter does I modified the filter so that the filter removes all frequency information above 2 kHz.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Make a smaller filter to remove more data and see what happens}
\PYG{c+c1}{\PYGZsh{} Find subset of indices where the frequency is between \PYGZhy{}2000 and 2000}
\PYG{n}{cos\PYGZus{}filt} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}
\PYG{n}{start} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{freqs} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{end} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{freqs} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{size} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{cos\PYGZus{}filt}\PYG{p}{[}\PYG{n}{start}\PYG{p}{:}\PYG{n}{end}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{size}\PYG{p}{)}
\PYG{n}{cos\PYGZus{}filt}\PYG{p}{[}\PYG{n}{start}\PYG{p}{:}\PYG{n}{end}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
In this case I start with the same size filter. I then find where the frequencies are above \sphinxhyphen{}2 kHz and below 2 kHz and use that information to generate the raised cosine filter. Once the filter has been created we can then apply it to the Fourier Transform of the data in the same manner that we did for the first filter.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{filtered\PYGZus{}ffts\PYGZus{}2} \PYG{o}{=} \PYG{n}{deepcopy}\PYG{p}{(}\PYG{n}{ffts}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{filtered\PYGZus{}ffts\PYGZus{}2}\PYG{p}{:}
    \PYG{n}{i} \PYG{o}{*}\PYG{o}{=} \PYG{n}{cos\PYGZus{}filt}

\PYG{c+c1}{\PYGZsh{} Plot filtered ffts}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{ax}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{v}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{freqs}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{filtered\PYGZus{}ffts\PYGZus{}2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{filtered\PYGZus{}ffts\PYGZus{}2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} v.plot(freqs, cos\PYGZus{}filt)}
    \PYG{n}{v}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Frequency (kHz)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{v}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Amplitude}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Left Channel}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Right Channel}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{suptitle}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Filtered Fourier Transform}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{096581f7e3b6c033e865da3f8199865a0051a680879adf5db1144ecb846a058f}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Inverse Fourier Transform. Plot. Play.}
\PYG{n}{filtered\PYGZus{}song\PYGZus{}2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{filtered\PYGZus{}ffts\PYGZus{}2}\PYG{p}{:}
    \PYG{n}{filtered\PYGZus{}song\PYGZus{}2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{ifft}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{real}\PYG{p}{)}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{ax}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{v}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{time}\PYG{p}{,} \PYG{n}{filtered\PYGZus{}song\PYGZus{}2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{v}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Time (s)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{v}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Amplitude}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Left Channel}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Right Channel}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{suptitle}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Filtered Song}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{Audio}\PYG{p}{(}\PYG{n}{filtered\PYGZus{}song\PYGZus{}2}\PYG{p}{,} \PYG{n}{rate}\PYG{o}{=}\PYG{n}{hz}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{159765779aeeea67ced341ed545ed172941d9fb010c21906727393391b9f1162}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.Audio object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now we can play all three tracks back to back to hear the difference.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Audio}\PYG{p}{(}\PYG{n}{channels}\PYG{p}{,} \PYG{n}{rate}\PYG{o}{=}\PYG{n}{hz}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.Audio object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Audio}\PYG{p}{(}\PYG{n}{filtered\PYGZus{}song}\PYG{p}{,} \PYG{n}{rate}\PYG{o}{=}\PYG{n}{hz}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.Audio object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Audio}\PYG{p}{(}\PYG{n}{filtered\PYGZus{}song\PYGZus{}2}\PYG{p}{,} \PYG{n}{rate}\PYG{o}{=}\PYG{n}{hz}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.Audio object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Conclusion}
\label{\detokenize{content/1_conclusion:conclusion}}\label{\detokenize{content/1_conclusion::doc}}
\sphinxAtStartPar
As can be seen and heard from the three versions of the audio files the regular raised cosine does not alter the song by very much. The modified raised cosine however does modify the song quite a bit. It sounds much more muffled as all the high frequency information has been discarded and all but the DC value have been reduced by the raised cosine filter. Similar results could be assumed if the filter was a Gaussian filter depending on the value of sigma.

\sphinxAtStartPar
Overall this was a really fun project and class in general. I truly feel like I have grown and learned a ton this semester. I have a much better understanding of how to write code and good programming practices as well as a better intuitive understanding of many of the physics concepts that we dealt with in this class. I’ve also learned to use fewer jokes while naming my variables. I opted to just rewrite everything rather than trying to navigate all my different Portal references in the project part 1 file.

\sphinxAtStartPar
\sphinxincludegraphics{{thecakeisalie}.jpg}







\renewcommand{\indexname}{Index}
\printindex
\end{document}